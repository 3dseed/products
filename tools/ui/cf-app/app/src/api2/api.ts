// tslint:disable
/**
 * @cf/server
 * A simple application demonstrating the basic usage of permissions with NestJS (JWT, PasswordHash, User, Group, Permission, ContentType)
 *
 * OpenAPI spec version: 0.0.2
 * Contact: admin@site15.ru
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


import * as url from "url";
import * as portableFetch from "portable-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "http://localhost".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = portableFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 *
 * @export
 * @interface AccountDto
 */
export interface AccountDto {
    /**
     *
     * @type {number}
     * @memberof AccountDto
     */
    id?: number;
    /**
     *
     * @type {string}
     * @memberof AccountDto
     */
    password?: string;
    /**
     *
     * @type {string}
     * @memberof AccountDto
     */
    lastLogin?: string;
    /**
     *
     * @type {boolean}
     * @memberof AccountDto
     */
    isSuperuser?: boolean;
    /**
     *
     * @type {string}
     * @memberof AccountDto
     */
    username?: string;
    /**
     *
     * @type {string}
     * @memberof AccountDto
     */
    firstName?: string;
    /**
     *
     * @type {string}
     * @memberof AccountDto
     */
    lastName?: string;
    /**
     *
     * @type {string}
     * @memberof AccountDto
     */
    email?: string;
    /**
     *
     * @type {boolean}
     * @memberof AccountDto
     */
    isStaff?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof AccountDto
     */
    isActive?: boolean;
    /**
     *
     * @type {string}
     * @memberof AccountDto
     */
    dateJoined?: string;
    /**
     *
     * @type {string}
     * @memberof AccountDto
     */
    dateOfBirth?: string;
    /**
     *
     * @type {Array&lt;GroupWithPermissionsDto&gt;}
     * @memberof AccountDto
     */
    groups?: Array<GroupWithPermissionsDto>;
}

/**
 *
 * @export
 * @interface ContentTypeDto
 */
export interface ContentTypeDto {
    /**
     *
     * @type {number}
     * @memberof ContentTypeDto
     */
    id?: number;
    /**
     *
     * @type {string}
     * @memberof ContentTypeDto
     */
    name?: string;
    /**
     *
     * @type {string}
     * @memberof ContentTypeDto
     */
    title?: string;
}

/**
 *
 * @export
 * @interface DeviceDto
 */
import { EventEmitter } from "events";
export class DeviceDto extends EventEmitter {
    /**
     *
     * @type {number}
     * @memberof DeviceDto
     */
    id?: number;
    /**
     *
     * @type {boolean}
     * @memberof DeviceDto
     */
    isActive?: boolean;
    /**
     *
     * @type {string}
     * @memberof DeviceDto
     */
    name?: string;
    /**
     *
     * @type {string}
     * @memberof DeviceDto
     */
    fields?: string;
    /**
     *
     * @type {number}
     * @memberof DeviceDto
     */
    user?: number;
    /**
     *
     * @type {number}
     * @memberof DeviceDto
     */
    project?: number;
    /**
     *
     * @type {number}
     * @memberof DeviceDto
     */
    flags?: number;
    /**
     *
     * @type {string}
     * @memberof DeviceDto
     */
    state?: string;
    /**
     *
     * @type {string}
     * @memberof DeviceDto
     */
    host?: string;
    /**
     *
     * @type {string}
     * @memberof DeviceDto
     */
    port?: string;
    /**
     *
     * @type {string}
     * @memberof DeviceDto
     */
    protocol?: string;
    /**
     *
     * @type {string}
     * @memberof DeviceDto
     */
    logging?: string;
    /**
     *
     * @type {string}
     * @memberof DeviceDto
     */
    retry?: string;
    /**
     *
     * @type {string}
     * @memberof DeviceDto
     */
    blocks?: string;
    /**
     *
     * @type {string}
     * @memberof DeviceDto
     */
    commandSettings?: string;
    /**
     *
     * @type {string}
     * @memberof DeviceDto
     */
    settings?: string;
}

/**
 *
 * @export
 * @interface FileDto
 */
export interface FileDto {
    /**
     *
     * @type {string}
     * @memberof FileDto
     */
    path?: string;
}

/**
 *
 * @export
 * @interface GroupDto
 */
export interface GroupDto {
    /**
     *
     * @type {number}
     * @memberof GroupDto
     */
    id?: number;
    /**
     *
     * @type {string}
     * @memberof GroupDto
     */
    name?: string;
    /**
     *
     * @type {string}
     * @memberof GroupDto
     */
    title?: string;
}

/**
 *
 * @export
 * @interface GroupWithPermissionsDto
 */
export interface GroupWithPermissionsDto {
    /**
     *
     * @type {number}
     * @memberof GroupWithPermissionsDto
     */
    id?: number;
    /**
     *
     * @type {string}
     * @memberof GroupWithPermissionsDto
     */
    name?: string;
    /**
     *
     * @type {string}
     * @memberof GroupWithPermissionsDto
     */
    title?: string;
    /**
     *
     * @type {Array&lt;PermissionDto&gt;}
     * @memberof GroupWithPermissionsDto
     */
    permissions?: Array<PermissionDto>;
}

/**
 *
 * @export
 * @interface InAccountDto
 */
export interface InAccountDto {
    /**
     *
     * @type {string}
     * @memberof InAccountDto
     */
    password?: string;
    /**
     *
     * @type {string}
     * @memberof InAccountDto
     */
    username?: string;
    /**
     *
     * @type {string}
     * @memberof InAccountDto
     */
    firstName?: string;
    /**
     *
     * @type {string}
     * @memberof InAccountDto
     */
    lastName?: string;
}

/**
 *
 * @export
 * @interface InAccountLoginDto
 */
export interface InAccountLoginDto {
    /**
     *
     * @type {string}
     * @memberof InAccountLoginDto
     */
    email?: string;
    /**
     *
     * @type {string}
     * @memberof InAccountLoginDto
     */
    password?: string;
}

/**
 *
 * @export
 * @interface InAccountRegisterDto
 */
export interface InAccountRegisterDto {
    /**
     *
     * @type {string}
     * @memberof InAccountRegisterDto
     */
    email?: string;
    /**
     *
     * @type {string}
     * @memberof InAccountRegisterDto
     */
    password?: string;
}

/**
 *
 * @export
 * @interface InContentTypeDto
 */
export interface InContentTypeDto {
    /**
     *
     * @type {string}
     * @memberof InContentTypeDto
     */
    name?: string;
    /**
     *
     * @type {string}
     * @memberof InContentTypeDto
     */
    title?: string;
}

/**
 *
 * @export
 * @interface InDeviceDto
 */
export interface InDeviceDto {
    /**
     *
     * @type {number}
     * @memberof InDeviceDto
     */
    id?: number;
    /**
     *
     * @type {boolean}
     * @memberof InDeviceDto
     */
    isActive?: boolean;
    /**
     *
     * @type {string}
     * @memberof InDeviceDto
     */
    name?: string;
    /**
     *
     * @type {string}
     * @memberof InDeviceDto
     */
    fields?: string;
    /**
     *
     * @type {number}
     * @memberof InDeviceDto
     */
    user?: number;
    /**
     *
     * @type {number}
     * @memberof InDeviceDto
     */
    project?: number;
    /**
     *
     * @type {number}
     * @memberof InDeviceDto
     */
    flags?: number;
    /**
     *
     * @type {string}
     * @memberof InDeviceDto
     */
    state?: string;
    /**
     *
     * @type {string}
     * @memberof InDeviceDto
     */
    host?: string;
    /**
     *
     * @type {string}
     * @memberof InDeviceDto
     */
    port?: string;
    /**
     *
     * @type {string}
     * @memberof InDeviceDto
     */
    protocol?: string;
    /**
     *
     * @type {string}
     * @memberof InDeviceDto
     */
    logging?: string;
    /**
     *
     * @type {string}
     * @memberof InDeviceDto
     */
    retry?: string;
    /**
     *
     * @type {string}
     * @memberof InDeviceDto
     */
    blocks?: string;
    /**
     *
     * @type {string}
     * @memberof InDeviceDto
     */
    commandSettings?: string;
    /**
     *
     * @type {string}
     * @memberof InDeviceDto
     */
    settings?: string;
}

/**
 *
 * @export
 * @interface InFileDto
 */
export interface InFileDto {
    /**
     *
     * @type {string}
     * @memberof InFileDto
     */
    path?: string;
}

/**
 *
 * @export
 * @interface InGroupDto
 */
export interface InGroupDto {
    /**
     *
     * @type {string}
     * @memberof InGroupDto
     */
    name?: string;
    /**
     *
     * @type {string}
     * @memberof InGroupDto
     */
    title?: string;
}

/**
 *
 * @export
 * @interface InPermissionDto
 */
export interface InPermissionDto {
    /**
     *
     * @type {string}
     * @memberof InPermissionDto
     */
    name?: string;
    /**
     *
     * @type {string}
     * @memberof InPermissionDto
     */
    title?: string;
    /**
     *
     * @type {ContentTypeDto}
     * @memberof InPermissionDto
     */
    contentType?: ContentTypeDto;
}

/**
 *
 * @export
 * @interface InProjectDto
 */
export interface InProjectDto {
    /**
     *
     * @type {number}
     * @memberof InProjectDto
     */
    id?: number;
    /**
     *
     * @type {number}
     * @memberof InProjectDto
     */
    user?: number;
    /**
     *
     * @type {string}
     * @memberof InProjectDto
     */
    name?: string;
    /**
     *
     * @type {string}
     * @memberof InProjectDto
     */
    settings?: string;
    /**
     *
     * @type {string}
     * @memberof InProjectDto
     */
    created?: string;
    /**
     *
     * @type {string}
     * @memberof InProjectDto
     */
    lastEdited?: string;
}

/**
 *
 * @export
 * @interface InTokenDto
 */
export interface InTokenDto {
    /**
     *
     * @type {string}
     * @memberof InTokenDto
     */
    token?: string;
}

/**
 *
 * @export
 * @interface InUserDto
 */
export interface InUserDto {
    /**
     *
     * @type {number}
     * @memberof InUserDto
     */
    id?: number;
    /**
     *
     * @type {string}
     * @memberof InUserDto
     */
    password?: string;
    /**
     *
     * @type {string}
     * @memberof InUserDto
     */
    lastLogin?: string;
    /**
     *
     * @type {boolean}
     * @memberof InUserDto
     */
    isSuperuser?: boolean;
    /**
     *
     * @type {string}
     * @memberof InUserDto
     */
    username?: string;
    /**
     *
     * @type {string}
     * @memberof InUserDto
     */
    firstName?: string;
    /**
     *
     * @type {string}
     * @memberof InUserDto
     */
    lastName?: string;
    /**
     *
     * @type {string}
     * @memberof InUserDto
     */
    email?: string;
    /**
     *
     * @type {boolean}
     * @memberof InUserDto
     */
    isStaff?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof InUserDto
     */
    isActive?: boolean;
    /**
     *
     * @type {string}
     * @memberof InUserDto
     */
    dateJoined?: string;
    /**
     *
     * @type {string}
     * @memberof InUserDto
     */
    dateOfBirth?: string;
    /**
     *
     * @type {Array&lt;GroupDto&gt;}
     * @memberof InUserDto
     */
    groups?: Array<GroupDto>;
}

/**
 *
 * @export
 * @interface MetaDto
 */
export interface MetaDto {
    /**
     *
     * @type {number}
     * @memberof MetaDto
     */
    perPage?: number;
    /**
     *
     * @type {number}
     * @memberof MetaDto
     */
    totalPages?: number;
    /**
     *
     * @type {number}
     * @memberof MetaDto
     */
    totalResults?: number;
    /**
     *
     * @type {number}
     * @memberof MetaDto
     */
    curPage?: number;
}

/**
 *
 * @export
 * @interface OutAccountTokenDto
 */
export interface OutAccountTokenDto {
    /**
     *
     * @type {string}
     * @memberof OutAccountTokenDto
     */
    token?: string;
    /**
     *
     * @type {AccountDto}
     * @memberof OutAccountTokenDto
     */
    user?: AccountDto;
}

/**
 *
 * @export
 * @interface OutContentTypeDto
 */
export interface OutContentTypeDto {
    /**
     *
     * @type {ContentTypeDto}
     * @memberof OutContentTypeDto
     */
    contentType?: ContentTypeDto;
}

/**
 *
 * @export
 * @interface OutContentTypesDto
 */
export interface OutContentTypesDto {
    /**
     *
     * @type {Array&lt;ContentTypeDto&gt;}
     * @memberof OutContentTypesDto
     */
    contentTypes?: Array<ContentTypeDto>;
    /**
     *
     * @type {MetaDto}
     * @memberof OutContentTypesDto
     */
    meta?: MetaDto;
}

/**
 *
 * @export
 * @interface OutDeviceDto
 */
export interface OutDeviceDto {
    /**
     *
     * @type {DeviceDto}
     * @memberof OutDeviceDto
     */
    device?: DeviceDto;
}

/**
 *
 * @export
 * @interface OutDevicesDto
 */
export interface OutDevicesDto {
    /**
     *
     * @type {Array&lt;DeviceDto&gt;}
     * @memberof OutDevicesDto
     */
    devices?: Array<DeviceDto>;
    /**
     *
     * @type {MetaDto}
     * @memberof OutDevicesDto
     */
    meta?: MetaDto;
}

/**
 *
 * @export
 * @interface OutFileDto
 */
export interface OutFileDto {
    /**
     *
     * @type {FileDto}
     * @memberof OutFileDto
     */
    file?: FileDto;
}

/**
 *
 * @export
 * @interface OutGroupDto
 */
export interface OutGroupDto {
    /**
     *
     * @type {GroupDto}
     * @memberof OutGroupDto
     */
    group?: GroupDto;
}

/**
 *
 * @export
 * @interface OutGroupsDto
 */
export interface OutGroupsDto {
    /**
     *
     * @type {Array&lt;GroupDto&gt;}
     * @memberof OutGroupsDto
     */
    groups?: Array<GroupDto>;
    /**
     *
     * @type {MetaDto}
     * @memberof OutGroupsDto
     */
    meta?: MetaDto;
}

/**
 *
 * @export
 * @interface OutPermissionDto
 */
export interface OutPermissionDto {
    /**
     *
     * @type {PermissionDto}
     * @memberof OutPermissionDto
     */
    permission?: PermissionDto;
}

/**
 *
 * @export
 * @interface OutPermissionsDto
 */
export interface OutPermissionsDto {
    /**
     *
     * @type {Array&lt;PermissionDto&gt;}
     * @memberof OutPermissionsDto
     */
    permissions?: Array<PermissionDto>;
    /**
     *
     * @type {MetaDto}
     * @memberof OutPermissionsDto
     */
    meta?: MetaDto;
}

/**
 *
 * @export
 * @interface OutProjectDto
 */
export interface OutProjectDto {
    /**
     *
     * @type {ProjectDto}
     * @memberof OutProjectDto
     */
    project?: ProjectDto;
}

/**
 *
 * @export
 * @interface OutUserDto
 */
export interface OutUserDto {
    /**
     *
     * @type {UserDto}
     * @memberof OutUserDto
     */
    user?: UserDto;
}

/**
 *
 * @export
 * @interface OutUsersDto
 */
export interface OutUsersDto {
    /**
     *
     * @type {Array&lt;UserDto&gt;}
     * @memberof OutUsersDto
     */
    users?: Array<UserDto>;
    /**
     *
     * @type {MetaDto}
     * @memberof OutUsersDto
     */
    meta?: MetaDto;
}

/**
 *
 * @export
 * @interface PermissionDto
 */
export interface PermissionDto {
    /**
     *
     * @type {number}
     * @memberof PermissionDto
     */
    id?: number;
    /**
     *
     * @type {string}
     * @memberof PermissionDto
     */
    name?: string;
    /**
     *
     * @type {string}
     * @memberof PermissionDto
     */
    title?: string;
    /**
     *
     * @type {ContentTypeDto}
     * @memberof PermissionDto
     */
    contentType?: ContentTypeDto;
}

/**
 *
 * @export
 * @interface ProjectDto
 */
export interface ProjectDto {
    /**
     *
     * @type {number}
     * @memberof ProjectDto
     */
    id?: number;
    /**
     *
     * @type {number}
     * @memberof ProjectDto
     */
    user?: number;
    /**
     *
     * @type {string}
     * @memberof ProjectDto
     */
    name?: string;
    /**
     *
     * @type {string}
     * @memberof ProjectDto
     */
    settings?: string;
    /**
     *
     * @type {string}
     * @memberof ProjectDto
     */
    created?: string;
    /**
     *
     * @type {string}
     * @memberof ProjectDto
     */
    lastEdited?: string;
}

/**
 *
 * @export
 * @interface UserDto
 */
export interface UserDto {
    /**
     *
     * @type {number}
     * @memberof UserDto
     */
    id?: number;
    /**
     *
     * @type {string}
     * @memberof UserDto
     */
    password?: string;
    /**
     *
     * @type {string}
     * @memberof UserDto
     */
    lastLogin?: string;
    /**
     *
     * @type {boolean}
     * @memberof UserDto
     */
    isSuperuser?: boolean;
    /**
     *
     * @type {string}
     * @memberof UserDto
     */
    username?: string;
    /**
     *
     * @type {string}
     * @memberof UserDto
     */
    firstName?: string;
    /**
     *
     * @type {string}
     * @memberof UserDto
     */
    lastName?: string;
    /**
     *
     * @type {string}
     * @memberof UserDto
     */
    email?: string;
    /**
     *
     * @type {boolean}
     * @memberof UserDto
     */
    isStaff?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof UserDto
     */
    isActive?: boolean;
    /**
     *
     * @type {string}
     * @memberof UserDto
     */
    dateJoined?: string;
    /**
     *
     * @type {string}
     * @memberof UserDto
     */
    dateOfBirth?: string;
    /**
     *
     * @type {Array&lt;GroupDto&gt;}
     * @memberof UserDto
     */
    groups?: Array<GroupDto>;
}


/**
 * AccountApi - fetch parameter creator
 * @export
 */
export const AccountApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {InTokenDto} inTokenDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAccountInfoPost(inTokenDto: InTokenDto, options: any = {}): FetchArgs {
            // verify required parameter 'inTokenDto' is not null or undefined
            if (inTokenDto === null || inTokenDto === undefined) {
                throw new RequiredError('inTokenDto','Required parameter inTokenDto was null or undefined when calling apiAccountInfoPost.');
            }
            const localVarPath = `/api/account/info`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"InTokenDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(inTokenDto || {}) : (inTokenDto || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {InAccountLoginDto} inAccountLoginDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAccountLoginPost(inAccountLoginDto: InAccountLoginDto, options: any = {}): FetchArgs {
            // verify required parameter 'inAccountLoginDto' is not null or undefined
            if (inAccountLoginDto === null || inAccountLoginDto === undefined) {
                throw new RequiredError('inAccountLoginDto','Required parameter inAccountLoginDto was null or undefined when calling apiAccountLoginPost.');
            }
            const localVarPath = `/api/account/login`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"InAccountLoginDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(inAccountLoginDto || {}) : (inAccountLoginDto || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {InAccountRegisterDto} inAccountRegisterDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAccountRegisterPost(inAccountRegisterDto: InAccountRegisterDto, options: any = {}): FetchArgs {
            // verify required parameter 'inAccountRegisterDto' is not null or undefined
            if (inAccountRegisterDto === null || inAccountRegisterDto === undefined) {
                throw new RequiredError('inAccountRegisterDto','Required parameter inAccountRegisterDto was null or undefined when calling apiAccountRegisterPost.');
            }
            const localVarPath = `/api/account/register`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"InAccountRegisterDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(inAccountRegisterDto || {}) : (inAccountRegisterDto || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {InAccountDto} inAccountDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAccountUpdatePost(inAccountDto: InAccountDto, options: any = {}): FetchArgs {
            // verify required parameter 'inAccountDto' is not null or undefined
            if (inAccountDto === null || inAccountDto === undefined) {
                throw new RequiredError('inAccountDto','Required parameter inAccountDto was null or undefined when calling apiAccountUpdatePost.');
            }
            const localVarPath = `/api/account/update`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"InAccountDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(inAccountDto || {}) : (inAccountDto || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountApi - functional programming interface
 * @export
 */
export const AccountApiFp = function(configuration?: Configuration) {
    return {
        /**
         *
         * @param {InTokenDto} inTokenDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAccountInfoPost(inTokenDto: InTokenDto, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OutAccountTokenDto> {
            const localVarFetchArgs = AccountApiFetchParamCreator(configuration).apiAccountInfoPost(inTokenDto, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @param {InAccountLoginDto} inAccountLoginDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAccountLoginPost(inAccountLoginDto: InAccountLoginDto, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OutAccountTokenDto> {
            const localVarFetchArgs = AccountApiFetchParamCreator(configuration).apiAccountLoginPost(inAccountLoginDto, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @param {InAccountRegisterDto} inAccountRegisterDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAccountRegisterPost(inAccountRegisterDto: InAccountRegisterDto, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OutAccountTokenDto> {
            const localVarFetchArgs = AccountApiFetchParamCreator(configuration).apiAccountRegisterPost(inAccountRegisterDto, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @param {InAccountDto} inAccountDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAccountUpdatePost(inAccountDto: InAccountDto, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OutAccountTokenDto> {
            const localVarFetchArgs = AccountApiFetchParamCreator(configuration).apiAccountUpdatePost(inAccountDto, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AccountApi - factory interface
 * @export
 */
export const AccountApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         *
         * @param {InTokenDto} inTokenDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAccountInfoPost(inTokenDto: InTokenDto, options?: any) {
            return AccountApiFp(configuration).apiAccountInfoPost(inTokenDto, options)(fetch, basePath);
        },
        /**
         *
         * @param {InAccountLoginDto} inAccountLoginDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAccountLoginPost(inAccountLoginDto: InAccountLoginDto, options?: any) {
            return AccountApiFp(configuration).apiAccountLoginPost(inAccountLoginDto, options)(fetch, basePath);
        },
        /**
         *
         * @param {InAccountRegisterDto} inAccountRegisterDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAccountRegisterPost(inAccountRegisterDto: InAccountRegisterDto, options?: any) {
            return AccountApiFp(configuration).apiAccountRegisterPost(inAccountRegisterDto, options)(fetch, basePath);
        },
        /**
         *
         * @param {InAccountDto} inAccountDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAccountUpdatePost(inAccountDto: InAccountDto, options?: any) {
            return AccountApiFp(configuration).apiAccountUpdatePost(inAccountDto, options)(fetch, basePath);
        },
    };
};

/**
 * AccountApi - object-oriented interface
 * @export
 * @class AccountApi
 * @extends {BaseAPI}
 */
export class AccountApi extends BaseAPI {
    /**
     *
     * @param {} inTokenDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public apiAccountInfoPost(inTokenDto: InTokenDto, options?: any) {
        return AccountApiFp(this.configuration).apiAccountInfoPost(inTokenDto, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @param {} inAccountLoginDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public apiAccountLoginPost(inAccountLoginDto: InAccountLoginDto, options?: any) {
        return AccountApiFp(this.configuration).apiAccountLoginPost(inAccountLoginDto, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @param {} inAccountRegisterDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public apiAccountRegisterPost(inAccountRegisterDto: InAccountRegisterDto, options?: any) {
        return AccountApiFp(this.configuration).apiAccountRegisterPost(inAccountRegisterDto, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @param {} inAccountDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public apiAccountUpdatePost(inAccountDto: InAccountDto, options?: any) {
        return AccountApiFp(this.configuration).apiAccountUpdatePost(inAccountDto, options)(this.fetch, this.basePath);
    }

}

/**
 * ContentTypesApi - fetch parameter creator
 * @export
 */
export const ContentTypesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {string} [q] Text for search (default: empty)
         * @param {number} [perPage] Number of results to return per page. (default: 10)
         * @param {number} [curPage] A page number within the paginated result set. (default: 1)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiContentTypesGet(q?: string, perPage?: number, curPage?: number, options: any = {}): FetchArgs {
            const localVarPath = `/api/content-types`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (curPage !== undefined) {
                localVarQueryParameter['cur_page'] = curPage;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiContentTypesIdDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling apiContentTypesIdDelete.');
            }
            const localVarPath = `/api/content-types/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiContentTypesIdGet(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling apiContentTypesIdGet.');
            }
            const localVarPath = `/api/content-types/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {InContentTypeDto} inContentTypeDto
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiContentTypesIdPut(inContentTypeDto: InContentTypeDto, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'inContentTypeDto' is not null or undefined
            if (inContentTypeDto === null || inContentTypeDto === undefined) {
                throw new RequiredError('inContentTypeDto','Required parameter inContentTypeDto was null or undefined when calling apiContentTypesIdPut.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling apiContentTypesIdPut.');
            }
            const localVarPath = `/api/content-types/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"InContentTypeDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(inContentTypeDto || {}) : (inContentTypeDto || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {InContentTypeDto} inContentTypeDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiContentTypesPost(inContentTypeDto: InContentTypeDto, options: any = {}): FetchArgs {
            // verify required parameter 'inContentTypeDto' is not null or undefined
            if (inContentTypeDto === null || inContentTypeDto === undefined) {
                throw new RequiredError('inContentTypeDto','Required parameter inContentTypeDto was null or undefined when calling apiContentTypesPost.');
            }
            const localVarPath = `/api/content-types`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"InContentTypeDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(inContentTypeDto || {}) : (inContentTypeDto || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContentTypesApi - functional programming interface
 * @export
 */
export const ContentTypesApiFp = function(configuration?: Configuration) {
    return {
        /**
         *
         * @param {string} [q] Text for search (default: empty)
         * @param {number} [perPage] Number of results to return per page. (default: 10)
         * @param {number} [curPage] A page number within the paginated result set. (default: 1)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiContentTypesGet(q?: string, perPage?: number, curPage?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OutContentTypesDto> {
            const localVarFetchArgs = ContentTypesApiFetchParamCreator(configuration).apiContentTypesGet(q, perPage, curPage, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiContentTypesIdDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ContentTypesApiFetchParamCreator(configuration).apiContentTypesIdDelete(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiContentTypesIdGet(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OutContentTypeDto> {
            const localVarFetchArgs = ContentTypesApiFetchParamCreator(configuration).apiContentTypesIdGet(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @param {InContentTypeDto} inContentTypeDto
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiContentTypesIdPut(inContentTypeDto: InContentTypeDto, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OutContentTypeDto> {
            const localVarFetchArgs = ContentTypesApiFetchParamCreator(configuration).apiContentTypesIdPut(inContentTypeDto, id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @param {InContentTypeDto} inContentTypeDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiContentTypesPost(inContentTypeDto: InContentTypeDto, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OutContentTypeDto> {
            const localVarFetchArgs = ContentTypesApiFetchParamCreator(configuration).apiContentTypesPost(inContentTypeDto, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ContentTypesApi - factory interface
 * @export
 */
export const ContentTypesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         *
         * @param {string} [q] Text for search (default: empty)
         * @param {number} [perPage] Number of results to return per page. (default: 10)
         * @param {number} [curPage] A page number within the paginated result set. (default: 1)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiContentTypesGet(q?: string, perPage?: number, curPage?: number, options?: any) {
            return ContentTypesApiFp(configuration).apiContentTypesGet(q, perPage, curPage, options)(fetch, basePath);
        },
        /**
         *
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiContentTypesIdDelete(id: number, options?: any) {
            return ContentTypesApiFp(configuration).apiContentTypesIdDelete(id, options)(fetch, basePath);
        },
        /**
         *
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiContentTypesIdGet(id: number, options?: any) {
            return ContentTypesApiFp(configuration).apiContentTypesIdGet(id, options)(fetch, basePath);
        },
        /**
         *
         * @param {InContentTypeDto} inContentTypeDto
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiContentTypesIdPut(inContentTypeDto: InContentTypeDto, id: number, options?: any) {
            return ContentTypesApiFp(configuration).apiContentTypesIdPut(inContentTypeDto, id, options)(fetch, basePath);
        },
        /**
         *
         * @param {InContentTypeDto} inContentTypeDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiContentTypesPost(inContentTypeDto: InContentTypeDto, options?: any) {
            return ContentTypesApiFp(configuration).apiContentTypesPost(inContentTypeDto, options)(fetch, basePath);
        },
    };
};

/**
 * ContentTypesApi - object-oriented interface
 * @export
 * @class ContentTypesApi
 * @extends {BaseAPI}
 */
export class ContentTypesApi extends BaseAPI {
    /**
     *
     * @param {} [q] Text for search (default: empty)
     * @param {} [perPage] Number of results to return per page. (default: 10)
     * @param {} [curPage] A page number within the paginated result set. (default: 1)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentTypesApi
     */
    public apiContentTypesGet(q?: string, perPage?: number, curPage?: number, options?: any) {
        return ContentTypesApiFp(this.configuration).apiContentTypesGet(q, perPage, curPage, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @param {} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentTypesApi
     */
    public apiContentTypesIdDelete(id: number, options?: any) {
        return ContentTypesApiFp(this.configuration).apiContentTypesIdDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @param {} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentTypesApi
     */
    public apiContentTypesIdGet(id: number, options?: any) {
        return ContentTypesApiFp(this.configuration).apiContentTypesIdGet(id, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @param {} inContentTypeDto
     * @param {} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentTypesApi
     */
    public apiContentTypesIdPut(inContentTypeDto: InContentTypeDto, id: number, options?: any) {
        return ContentTypesApiFp(this.configuration).apiContentTypesIdPut(inContentTypeDto, id, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @param {} inContentTypeDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentTypesApi
     */
    public apiContentTypesPost(inContentTypeDto: InContentTypeDto, options?: any) {
        return ContentTypesApiFp(this.configuration).apiContentTypesPost(inContentTypeDto, options)(this.fetch, this.basePath);
    }

}

/**
 * DevicesApi - fetch parameter creator
 * @export
 */
export const DevicesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {number} [project] Group id for filter data by group. (default: empty)
         * @param {number} [group] Group id for filter data by group. (default: empty)
         * @param {string} [q] Text for search (default: empty)
         * @param {number} [perPage] Number of results to return per page. (default: 10)
         * @param {number} [curPage] A page number within the paginated result set. (default: 1)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDevicesGet(project?: number, group?: number, q?: string, perPage?: number, curPage?: number, options: any = {}): FetchArgs {
            const localVarPath = `/api/devices`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (project !== undefined) {
                localVarQueryParameter['project'] = project;
            }

            if (group !== undefined) {
                localVarQueryParameter['group'] = group;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (curPage !== undefined) {
                localVarQueryParameter['cur_page'] = curPage;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDevicesIdDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling apiDevicesIdDelete.');
            }
            const localVarPath = `/api/devices/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDevicesIdGet(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling apiDevicesIdGet.');
            }
            const localVarPath = `/api/devices/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {InDeviceDto} inDeviceDto
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDevicesIdPut(inDeviceDto: InDeviceDto, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'inDeviceDto' is not null or undefined
            if (inDeviceDto === null || inDeviceDto === undefined) {
                throw new RequiredError('inDeviceDto','Required parameter inDeviceDto was null or undefined when calling apiDevicesIdPut.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling apiDevicesIdPut.');
            }
            const localVarPath = `/api/devices/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"InDeviceDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(inDeviceDto || {}) : (inDeviceDto || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {InDeviceDto} inDeviceDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDevicesPost(inDeviceDto: InDeviceDto, options: any = {}): FetchArgs {
            // verify required parameter 'inDeviceDto' is not null or undefined
            if (inDeviceDto === null || inDeviceDto === undefined) {
                throw new RequiredError('inDeviceDto','Required parameter inDeviceDto was null or undefined when calling apiDevicesPost.');
            }
            const localVarPath = `/api/devices`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"InDeviceDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(inDeviceDto || {}) : (inDeviceDto || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDevicesStartIdPost(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling apiDevicesStartIdPost.');
            }
            const localVarPath = `/api/devices/start/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDevicesStopIdPost(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling apiDevicesStopIdPost.');
            }
            const localVarPath = `/api/devices/stop/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DevicesApi - functional programming interface
 * @export
 */
export const DevicesApiFp = function(configuration?: Configuration) {
    return {
        /**
         *
         * @param {number} [project] Group id for filter data by group. (default: empty)
         * @param {number} [group] Group id for filter data by group. (default: empty)
         * @param {string} [q] Text for search (default: empty)
         * @param {number} [perPage] Number of results to return per page. (default: 10)
         * @param {number} [curPage] A page number within the paginated result set. (default: 1)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDevicesGet(project?: number, group?: number, q?: string, perPage?: number, curPage?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OutDevicesDto> {
            const localVarFetchArgs = DevicesApiFetchParamCreator(configuration).apiDevicesGet(project, group, q, perPage, curPage, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDevicesIdDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DevicesApiFetchParamCreator(configuration).apiDevicesIdDelete(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDevicesIdGet(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OutDeviceDto> {
            const localVarFetchArgs = DevicesApiFetchParamCreator(configuration).apiDevicesIdGet(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @param {InDeviceDto} inDeviceDto
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDevicesIdPut(inDeviceDto: InDeviceDto, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OutDeviceDto> {
            const localVarFetchArgs = DevicesApiFetchParamCreator(configuration).apiDevicesIdPut(inDeviceDto, id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @param {InDeviceDto} inDeviceDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDevicesPost(inDeviceDto: InDeviceDto, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OutDeviceDto> {
            const localVarFetchArgs = DevicesApiFetchParamCreator(configuration).apiDevicesPost(inDeviceDto, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDevicesStartIdPost(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OutDeviceDto> {
            const localVarFetchArgs = DevicesApiFetchParamCreator(configuration).apiDevicesStartIdPost(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDevicesStopIdPost(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OutDeviceDto> {
            const localVarFetchArgs = DevicesApiFetchParamCreator(configuration).apiDevicesStopIdPost(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * DevicesApi - factory interface
 * @export
 */
export const DevicesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         *
         * @param {number} [project] Group id for filter data by group. (default: empty)
         * @param {number} [group] Group id for filter data by group. (default: empty)
         * @param {string} [q] Text for search (default: empty)
         * @param {number} [perPage] Number of results to return per page. (default: 10)
         * @param {number} [curPage] A page number within the paginated result set. (default: 1)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDevicesGet(project?: number, group?: number, q?: string, perPage?: number, curPage?: number, options?: any) {
            return DevicesApiFp(configuration).apiDevicesGet(project, group, q, perPage, curPage, options)(fetch, basePath);
        },
        /**
         *
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDevicesIdDelete(id: number, options?: any) {
            return DevicesApiFp(configuration).apiDevicesIdDelete(id, options)(fetch, basePath);
        },
        /**
         *
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDevicesIdGet(id: number, options?: any) {
            return DevicesApiFp(configuration).apiDevicesIdGet(id, options)(fetch, basePath);
        },
        /**
         *
         * @param {InDeviceDto} inDeviceDto
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDevicesIdPut(inDeviceDto: InDeviceDto, id: number, options?: any) {
            return DevicesApiFp(configuration).apiDevicesIdPut(inDeviceDto, id, options)(fetch, basePath);
        },
        /**
         *
         * @param {InDeviceDto} inDeviceDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDevicesPost(inDeviceDto: InDeviceDto, options?: any) {
            return DevicesApiFp(configuration).apiDevicesPost(inDeviceDto, options)(fetch, basePath);
        },
        /**
         *
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDevicesStartIdPost(id: number, options?: any) {
            return DevicesApiFp(configuration).apiDevicesStartIdPost(id, options)(fetch, basePath);
        },
        /**
         *
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDevicesStopIdPost(id: number, options?: any) {
            return DevicesApiFp(configuration).apiDevicesStopIdPost(id, options)(fetch, basePath);
        },
    };
};

/**
 * DevicesApi - object-oriented interface
 * @export
 * @class DevicesApi
 * @extends {BaseAPI}
 */
export class DevicesApi extends BaseAPI {
    /**
     *
     * @param {} [project] Group id for filter data by group. (default: empty)
     * @param {} [group] Group id for filter data by group. (default: empty)
     * @param {} [q] Text for search (default: empty)
     * @param {} [perPage] Number of results to return per page. (default: 10)
     * @param {} [curPage] A page number within the paginated result set. (default: 1)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public apiDevicesGet(project?: number, group?: number, q?: string, perPage?: number, curPage?: number, options?: any) {
        return DevicesApiFp(this.configuration).apiDevicesGet(project, group, q, perPage, curPage, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @param {} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public apiDevicesIdDelete(id: number, options?: any) {
        return DevicesApiFp(this.configuration).apiDevicesIdDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @param {} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public apiDevicesIdGet(id: number, options?: any) {
        return DevicesApiFp(this.configuration).apiDevicesIdGet(id, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @param {} inDeviceDto
     * @param {} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public apiDevicesIdPut(inDeviceDto: InDeviceDto, id: number, options?: any) {
        return DevicesApiFp(this.configuration).apiDevicesIdPut(inDeviceDto, id, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @param {} inDeviceDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public apiDevicesPost(inDeviceDto: InDeviceDto, options?: any) {
        return DevicesApiFp(this.configuration).apiDevicesPost(inDeviceDto, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @param {} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public apiDevicesStartIdPost(id: number, options?: any) {
        return DevicesApiFp(this.configuration).apiDevicesStartIdPost(id, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @param {} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public apiDevicesStopIdPost(id: number, options?: any) {
        return DevicesApiFp(this.configuration).apiDevicesStopIdPost(id, options)(this.fetch, this.basePath);
    }

}

/**
 * GroupsApi - fetch parameter creator
 * @export
 */
export const GroupsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {string} [q] Text for search (default: empty)
         * @param {number} [perPage] Number of results to return per page. (default: 10)
         * @param {number} [curPage] A page number within the paginated result set. (default: 1)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiGroupsGet(q?: string, perPage?: number, curPage?: number, options: any = {}): FetchArgs {
            const localVarPath = `/api/groups`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (curPage !== undefined) {
                localVarQueryParameter['cur_page'] = curPage;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiGroupsIdDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling apiGroupsIdDelete.');
            }
            const localVarPath = `/api/groups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiGroupsIdGet(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling apiGroupsIdGet.');
            }
            const localVarPath = `/api/groups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {InGroupDto} inGroupDto
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiGroupsIdPut(inGroupDto: InGroupDto, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'inGroupDto' is not null or undefined
            if (inGroupDto === null || inGroupDto === undefined) {
                throw new RequiredError('inGroupDto','Required parameter inGroupDto was null or undefined when calling apiGroupsIdPut.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling apiGroupsIdPut.');
            }
            const localVarPath = `/api/groups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"InGroupDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(inGroupDto || {}) : (inGroupDto || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {InGroupDto} inGroupDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiGroupsPost(inGroupDto: InGroupDto, options: any = {}): FetchArgs {
            // verify required parameter 'inGroupDto' is not null or undefined
            if (inGroupDto === null || inGroupDto === undefined) {
                throw new RequiredError('inGroupDto','Required parameter inGroupDto was null or undefined when calling apiGroupsPost.');
            }
            const localVarPath = `/api/groups`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"InGroupDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(inGroupDto || {}) : (inGroupDto || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GroupsApi - functional programming interface
 * @export
 */
export const GroupsApiFp = function(configuration?: Configuration) {
    return {
        /**
         *
         * @param {string} [q] Text for search (default: empty)
         * @param {number} [perPage] Number of results to return per page. (default: 10)
         * @param {number} [curPage] A page number within the paginated result set. (default: 1)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiGroupsGet(q?: string, perPage?: number, curPage?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OutGroupsDto> {
            const localVarFetchArgs = GroupsApiFetchParamCreator(configuration).apiGroupsGet(q, perPage, curPage, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiGroupsIdDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = GroupsApiFetchParamCreator(configuration).apiGroupsIdDelete(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiGroupsIdGet(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OutGroupDto> {
            const localVarFetchArgs = GroupsApiFetchParamCreator(configuration).apiGroupsIdGet(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @param {InGroupDto} inGroupDto
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiGroupsIdPut(inGroupDto: InGroupDto, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OutGroupDto> {
            const localVarFetchArgs = GroupsApiFetchParamCreator(configuration).apiGroupsIdPut(inGroupDto, id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @param {InGroupDto} inGroupDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiGroupsPost(inGroupDto: InGroupDto, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OutGroupDto> {
            const localVarFetchArgs = GroupsApiFetchParamCreator(configuration).apiGroupsPost(inGroupDto, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * GroupsApi - factory interface
 * @export
 */
export const GroupsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         *
         * @param {string} [q] Text for search (default: empty)
         * @param {number} [perPage] Number of results to return per page. (default: 10)
         * @param {number} [curPage] A page number within the paginated result set. (default: 1)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiGroupsGet(q?: string, perPage?: number, curPage?: number, options?: any) {
            return GroupsApiFp(configuration).apiGroupsGet(q, perPage, curPage, options)(fetch, basePath);
        },
        /**
         *
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiGroupsIdDelete(id: number, options?: any) {
            return GroupsApiFp(configuration).apiGroupsIdDelete(id, options)(fetch, basePath);
        },
        /**
         *
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiGroupsIdGet(id: number, options?: any) {
            return GroupsApiFp(configuration).apiGroupsIdGet(id, options)(fetch, basePath);
        },
        /**
         *
         * @param {InGroupDto} inGroupDto
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiGroupsIdPut(inGroupDto: InGroupDto, id: number, options?: any) {
            return GroupsApiFp(configuration).apiGroupsIdPut(inGroupDto, id, options)(fetch, basePath);
        },
        /**
         *
         * @param {InGroupDto} inGroupDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiGroupsPost(inGroupDto: InGroupDto, options?: any) {
            return GroupsApiFp(configuration).apiGroupsPost(inGroupDto, options)(fetch, basePath);
        },
    };
};

/**
 * GroupsApi - object-oriented interface
 * @export
 * @class GroupsApi
 * @extends {BaseAPI}
 */
export class GroupsApi extends BaseAPI {
    /**
     *
     * @param {} [q] Text for search (default: empty)
     * @param {} [perPage] Number of results to return per page. (default: 10)
     * @param {} [curPage] A page number within the paginated result set. (default: 1)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public apiGroupsGet(q?: string, perPage?: number, curPage?: number, options?: any) {
        return GroupsApiFp(this.configuration).apiGroupsGet(q, perPage, curPage, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @param {} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public apiGroupsIdDelete(id: number, options?: any) {
        return GroupsApiFp(this.configuration).apiGroupsIdDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @param {} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public apiGroupsIdGet(id: number, options?: any) {
        return GroupsApiFp(this.configuration).apiGroupsIdGet(id, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @param {} inGroupDto
     * @param {} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public apiGroupsIdPut(inGroupDto: InGroupDto, id: number, options?: any) {
        return GroupsApiFp(this.configuration).apiGroupsIdPut(inGroupDto, id, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @param {} inGroupDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public apiGroupsPost(inGroupDto: InGroupDto, options?: any) {
        return GroupsApiFp(this.configuration).apiGroupsPost(inGroupDto, options)(this.fetch, this.basePath);
    }

}

/**
 * PermissionsApi - fetch parameter creator
 * @export
 */
export const PermissionsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {number} [contentType] Content type id for filter data by content type. (default: empty)
         * @param {number} [group] Group id for filter data by group. (default: empty)
         * @param {string} [q] Text for search (default: empty)
         * @param {number} [perPage] Number of results to return per page. (default: 10)
         * @param {number} [curPage] A page number within the paginated result set. (default: 1)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPermissionsGet(contentType?: number, group?: number, q?: string, perPage?: number, curPage?: number, options: any = {}): FetchArgs {
            const localVarPath = `/api/permissions`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (contentType !== undefined) {
                localVarQueryParameter['content_type'] = contentType;
            }

            if (group !== undefined) {
                localVarQueryParameter['group'] = group;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (curPage !== undefined) {
                localVarQueryParameter['cur_page'] = curPage;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPermissionsIdDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling apiPermissionsIdDelete.');
            }
            const localVarPath = `/api/permissions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPermissionsIdGet(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling apiPermissionsIdGet.');
            }
            const localVarPath = `/api/permissions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {InPermissionDto} inPermissionDto
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPermissionsIdPut(inPermissionDto: InPermissionDto, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'inPermissionDto' is not null or undefined
            if (inPermissionDto === null || inPermissionDto === undefined) {
                throw new RequiredError('inPermissionDto','Required parameter inPermissionDto was null or undefined when calling apiPermissionsIdPut.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling apiPermissionsIdPut.');
            }
            const localVarPath = `/api/permissions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"InPermissionDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(inPermissionDto || {}) : (inPermissionDto || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {InPermissionDto} inPermissionDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPermissionsPost(inPermissionDto: InPermissionDto, options: any = {}): FetchArgs {
            // verify required parameter 'inPermissionDto' is not null or undefined
            if (inPermissionDto === null || inPermissionDto === undefined) {
                throw new RequiredError('inPermissionDto','Required parameter inPermissionDto was null or undefined when calling apiPermissionsPost.');
            }
            const localVarPath = `/api/permissions`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"InPermissionDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(inPermissionDto || {}) : (inPermissionDto || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PermissionsApi - functional programming interface
 * @export
 */
export const PermissionsApiFp = function(configuration?: Configuration) {
    return {
        /**
         *
         * @param {number} [contentType] Content type id for filter data by content type. (default: empty)
         * @param {number} [group] Group id for filter data by group. (default: empty)
         * @param {string} [q] Text for search (default: empty)
         * @param {number} [perPage] Number of results to return per page. (default: 10)
         * @param {number} [curPage] A page number within the paginated result set. (default: 1)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPermissionsGet(contentType?: number, group?: number, q?: string, perPage?: number, curPage?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OutPermissionsDto> {
            const localVarFetchArgs = PermissionsApiFetchParamCreator(configuration).apiPermissionsGet(contentType, group, q, perPage, curPage, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPermissionsIdDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PermissionsApiFetchParamCreator(configuration).apiPermissionsIdDelete(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPermissionsIdGet(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OutPermissionDto> {
            const localVarFetchArgs = PermissionsApiFetchParamCreator(configuration).apiPermissionsIdGet(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @param {InPermissionDto} inPermissionDto
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPermissionsIdPut(inPermissionDto: InPermissionDto, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OutPermissionDto> {
            const localVarFetchArgs = PermissionsApiFetchParamCreator(configuration).apiPermissionsIdPut(inPermissionDto, id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @param {InPermissionDto} inPermissionDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPermissionsPost(inPermissionDto: InPermissionDto, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OutPermissionDto> {
            const localVarFetchArgs = PermissionsApiFetchParamCreator(configuration).apiPermissionsPost(inPermissionDto, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * PermissionsApi - factory interface
 * @export
 */
export const PermissionsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         *
         * @param {number} [contentType] Content type id for filter data by content type. (default: empty)
         * @param {number} [group] Group id for filter data by group. (default: empty)
         * @param {string} [q] Text for search (default: empty)
         * @param {number} [perPage] Number of results to return per page. (default: 10)
         * @param {number} [curPage] A page number within the paginated result set. (default: 1)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPermissionsGet(contentType?: number, group?: number, q?: string, perPage?: number, curPage?: number, options?: any) {
            return PermissionsApiFp(configuration).apiPermissionsGet(contentType, group, q, perPage, curPage, options)(fetch, basePath);
        },
        /**
         *
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPermissionsIdDelete(id: number, options?: any) {
            return PermissionsApiFp(configuration).apiPermissionsIdDelete(id, options)(fetch, basePath);
        },
        /**
         *
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPermissionsIdGet(id: number, options?: any) {
            return PermissionsApiFp(configuration).apiPermissionsIdGet(id, options)(fetch, basePath);
        },
        /**
         *
         * @param {InPermissionDto} inPermissionDto
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPermissionsIdPut(inPermissionDto: InPermissionDto, id: number, options?: any) {
            return PermissionsApiFp(configuration).apiPermissionsIdPut(inPermissionDto, id, options)(fetch, basePath);
        },
        /**
         *
         * @param {InPermissionDto} inPermissionDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPermissionsPost(inPermissionDto: InPermissionDto, options?: any) {
            return PermissionsApiFp(configuration).apiPermissionsPost(inPermissionDto, options)(fetch, basePath);
        },
    };
};

/**
 * PermissionsApi - object-oriented interface
 * @export
 * @class PermissionsApi
 * @extends {BaseAPI}
 */
export class PermissionsApi extends BaseAPI {
    /**
     *
     * @param {} [contentType] Content type id for filter data by content type. (default: empty)
     * @param {} [group] Group id for filter data by group. (default: empty)
     * @param {} [q] Text for search (default: empty)
     * @param {} [perPage] Number of results to return per page. (default: 10)
     * @param {} [curPage] A page number within the paginated result set. (default: 1)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PermissionsApi
     */
    public apiPermissionsGet(contentType?: number, group?: number, q?: string, perPage?: number, curPage?: number, options?: any) {
        return PermissionsApiFp(this.configuration).apiPermissionsGet(contentType, group, q, perPage, curPage, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @param {} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PermissionsApi
     */
    public apiPermissionsIdDelete(id: number, options?: any) {
        return PermissionsApiFp(this.configuration).apiPermissionsIdDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @param {} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PermissionsApi
     */
    public apiPermissionsIdGet(id: number, options?: any) {
        return PermissionsApiFp(this.configuration).apiPermissionsIdGet(id, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @param {} inPermissionDto
     * @param {} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PermissionsApi
     */
    public apiPermissionsIdPut(inPermissionDto: InPermissionDto, id: number, options?: any) {
        return PermissionsApiFp(this.configuration).apiPermissionsIdPut(inPermissionDto, id, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @param {} inPermissionDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PermissionsApi
     */
    public apiPermissionsPost(inPermissionDto: InPermissionDto, options?: any) {
        return PermissionsApiFp(this.configuration).apiPermissionsPost(inPermissionDto, options)(this.fetch, this.basePath);
    }

}

/**
 * ProjectsApi - fetch parameter creator
 * @export
 */
export const ProjectsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {string} [q] Text for search (default: empty)
         * @param {number} [perPage] Number of results to return per page. (default: 10)
         * @param {number} [curPage] A page number within the paginated result set. (default: 1)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiProjectsGet(q?: string, perPage?: number, curPage?: number, options: any = {}): FetchArgs {
            const localVarPath = `/api/projects`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (curPage !== undefined) {
                localVarQueryParameter['cur_page'] = curPage;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiProjectsIdDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling apiProjectsIdDelete.');
            }
            const localVarPath = `/api/projects/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiProjectsIdGet(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling apiProjectsIdGet.');
            }
            const localVarPath = `/api/projects/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {InProjectDto} inProjectDto
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiProjectsIdPut(inProjectDto: InProjectDto, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'inProjectDto' is not null or undefined
            if (inProjectDto === null || inProjectDto === undefined) {
                throw new RequiredError('inProjectDto','Required parameter inProjectDto was null or undefined when calling apiProjectsIdPut.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling apiProjectsIdPut.');
            }
            const localVarPath = `/api/projects/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"InProjectDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(inProjectDto || {}) : (inProjectDto || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {InProjectDto} inProjectDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiProjectsPost(inProjectDto: InProjectDto, options: any = {}): FetchArgs {
            // verify required parameter 'inProjectDto' is not null or undefined
            if (inProjectDto === null || inProjectDto === undefined) {
                throw new RequiredError('inProjectDto','Required parameter inProjectDto was null or undefined when calling apiProjectsPost.');
            }
            const localVarPath = `/api/projects`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"InProjectDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(inProjectDto || {}) : (inProjectDto || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProjectsApi - functional programming interface
 * @export
 */
export const ProjectsApiFp = function(configuration?: Configuration) {
    return {
        /**
         *
         * @param {string} [q] Text for search (default: empty)
         * @param {number} [perPage] Number of results to return per page. (default: 10)
         * @param {number} [curPage] A page number within the paginated result set. (default: 1)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiProjectsGet(q?: string, perPage?: number, curPage?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OutProjectDto> {
            const localVarFetchArgs = ProjectsApiFetchParamCreator(configuration).apiProjectsGet(q, perPage, curPage, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiProjectsIdDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ProjectsApiFetchParamCreator(configuration).apiProjectsIdDelete(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiProjectsIdGet(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OutProjectDto> {
            const localVarFetchArgs = ProjectsApiFetchParamCreator(configuration).apiProjectsIdGet(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @param {InProjectDto} inProjectDto
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiProjectsIdPut(inProjectDto: InProjectDto, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OutProjectDto> {
            const localVarFetchArgs = ProjectsApiFetchParamCreator(configuration).apiProjectsIdPut(inProjectDto, id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @param {InProjectDto} inProjectDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiProjectsPost(inProjectDto: InProjectDto, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OutProjectDto> {
            const localVarFetchArgs = ProjectsApiFetchParamCreator(configuration).apiProjectsPost(inProjectDto, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ProjectsApi - factory interface
 * @export
 */
export const ProjectsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         *
         * @param {string} [q] Text for search (default: empty)
         * @param {number} [perPage] Number of results to return per page. (default: 10)
         * @param {number} [curPage] A page number within the paginated result set. (default: 1)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiProjectsGet(q?: string, perPage?: number, curPage?: number, options?: any) {
            return ProjectsApiFp(configuration).apiProjectsGet(q, perPage, curPage, options)(fetch, basePath);
        },
        /**
         *
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiProjectsIdDelete(id: number, options?: any) {
            return ProjectsApiFp(configuration).apiProjectsIdDelete(id, options)(fetch, basePath);
        },
        /**
         *
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiProjectsIdGet(id: number, options?: any) {
            return ProjectsApiFp(configuration).apiProjectsIdGet(id, options)(fetch, basePath);
        },
        /**
         *
         * @param {InProjectDto} inProjectDto
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiProjectsIdPut(inProjectDto: InProjectDto, id: number, options?: any) {
            return ProjectsApiFp(configuration).apiProjectsIdPut(inProjectDto, id, options)(fetch, basePath);
        },
        /**
         *
         * @param {InProjectDto} inProjectDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiProjectsPost(inProjectDto: InProjectDto, options?: any) {
            return ProjectsApiFp(configuration).apiProjectsPost(inProjectDto, options)(fetch, basePath);
        },
    };
};

/**
 * ProjectsApi - object-oriented interface
 * @export
 * @class ProjectsApi
 * @extends {BaseAPI}
 */
export class ProjectsApi extends BaseAPI {
    /**
     *
     * @param {} [q] Text for search (default: empty)
     * @param {} [perPage] Number of results to return per page. (default: 10)
     * @param {} [curPage] A page number within the paginated result set. (default: 1)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public apiProjectsGet(q?: string, perPage?: number, curPage?: number, options?: any) {
        return ProjectsApiFp(this.configuration).apiProjectsGet(q, perPage, curPage, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @param {} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public apiProjectsIdDelete(id: number, options?: any) {
        return ProjectsApiFp(this.configuration).apiProjectsIdDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @param {} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public apiProjectsIdGet(id: number, options?: any) {
        return ProjectsApiFp(this.configuration).apiProjectsIdGet(id, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @param {} inProjectDto
     * @param {} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public apiProjectsIdPut(inProjectDto: InProjectDto, id: number, options?: any) {
        return ProjectsApiFp(this.configuration).apiProjectsIdPut(inProjectDto, id, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @param {} inProjectDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public apiProjectsPost(inProjectDto: InProjectDto, options?: any) {
        return ProjectsApiFp(this.configuration).apiProjectsPost(inProjectDto, options)(this.fetch, this.basePath);
    }

}

/**
 * UsersApi - fetch parameter creator
 * @export
 */
export const UsersApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {number} [group] Group id for filter data by group. (default: empty)
         * @param {string} [q] Text for search (default: empty)
         * @param {number} [perPage] Number of results to return per page. (default: 10)
         * @param {number} [curPage] A page number within the paginated result set. (default: 1)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersGet(group?: number, q?: string, perPage?: number, curPage?: number, options: any = {}): FetchArgs {
            const localVarPath = `/api/users`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (group !== undefined) {
                localVarQueryParameter['group'] = group;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (curPage !== undefined) {
                localVarQueryParameter['cur_page'] = curPage;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersIdDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling apiUsersIdDelete.');
            }
            const localVarPath = `/api/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersIdGet(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling apiUsersIdGet.');
            }
            const localVarPath = `/api/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {InUserDto} inUserDto
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersIdPut(inUserDto: InUserDto, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'inUserDto' is not null or undefined
            if (inUserDto === null || inUserDto === undefined) {
                throw new RequiredError('inUserDto','Required parameter inUserDto was null or undefined when calling apiUsersIdPut.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling apiUsersIdPut.');
            }
            const localVarPath = `/api/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"InUserDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(inUserDto || {}) : (inUserDto || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {InUserDto} inUserDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersPost(inUserDto: InUserDto, options: any = {}): FetchArgs {
            // verify required parameter 'inUserDto' is not null or undefined
            if (inUserDto === null || inUserDto === undefined) {
                throw new RequiredError('inUserDto','Required parameter inUserDto was null or undefined when calling apiUsersPost.');
            }
            const localVarPath = `/api/users`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"InUserDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(inUserDto || {}) : (inUserDto || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    return {
        /**
         *
         * @param {number} [group] Group id for filter data by group. (default: empty)
         * @param {string} [q] Text for search (default: empty)
         * @param {number} [perPage] Number of results to return per page. (default: 10)
         * @param {number} [curPage] A page number within the paginated result set. (default: 1)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersGet(group?: number, q?: string, perPage?: number, curPage?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OutUsersDto> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).apiUsersGet(group, q, perPage, curPage, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersIdDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).apiUsersIdDelete(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersIdGet(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OutUserDto> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).apiUsersIdGet(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @param {InUserDto} inUserDto
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersIdPut(inUserDto: InUserDto, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OutUserDto> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).apiUsersIdPut(inUserDto, id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @param {InUserDto} inUserDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersPost(inUserDto: InUserDto, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OutUserDto> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).apiUsersPost(inUserDto, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         *
         * @param {number} [group] Group id for filter data by group. (default: empty)
         * @param {string} [q] Text for search (default: empty)
         * @param {number} [perPage] Number of results to return per page. (default: 10)
         * @param {number} [curPage] A page number within the paginated result set. (default: 1)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersGet(group?: number, q?: string, perPage?: number, curPage?: number, options?: any) {
            return UsersApiFp(configuration).apiUsersGet(group, q, perPage, curPage, options)(fetch, basePath);
        },
        /**
         *
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersIdDelete(id: number, options?: any) {
            return UsersApiFp(configuration).apiUsersIdDelete(id, options)(fetch, basePath);
        },
        /**
         *
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersIdGet(id: number, options?: any) {
            return UsersApiFp(configuration).apiUsersIdGet(id, options)(fetch, basePath);
        },
        /**
         *
         * @param {InUserDto} inUserDto
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersIdPut(inUserDto: InUserDto, id: number, options?: any) {
            return UsersApiFp(configuration).apiUsersIdPut(inUserDto, id, options)(fetch, basePath);
        },
        /**
         *
         * @param {InUserDto} inUserDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersPost(inUserDto: InUserDto, options?: any) {
            return UsersApiFp(configuration).apiUsersPost(inUserDto, options)(fetch, basePath);
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     *
     * @param {} [group] Group id for filter data by group. (default: empty)
     * @param {} [q] Text for search (default: empty)
     * @param {} [perPage] Number of results to return per page. (default: 10)
     * @param {} [curPage] A page number within the paginated result set. (default: 1)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public apiUsersGet(group?: number, q?: string, perPage?: number, curPage?: number, options?: any) {
        return UsersApiFp(this.configuration).apiUsersGet(group, q, perPage, curPage, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @param {} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public apiUsersIdDelete(id: number, options?: any) {
        return UsersApiFp(this.configuration).apiUsersIdDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @param {} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public apiUsersIdGet(id: number, options?: any) {
        return UsersApiFp(this.configuration).apiUsersIdGet(id, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @param {} inUserDto
     * @param {} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public apiUsersIdPut(inUserDto: InUserDto, id: number, options?: any) {
        return UsersApiFp(this.configuration).apiUsersIdPut(inUserDto, id, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @param {} inUserDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public apiUsersPost(inUserDto: InUserDto, options?: any) {
        return UsersApiFp(this.configuration).apiUsersPost(inUserDto, options)(this.fetch, this.basePath);
    }

}

/**
 * VfsApi - fetch parameter creator
 * @export
 */
export const VfsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {string} [q] Text for search (default: empty)
         * @param {number} [perPage] Number of results to return per page. (default: 10)
         * @param {number} [curPage] A page number within the paginated result set. (default: 1)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiVfsGet(q?: string, perPage?: number, curPage?: number, options: any = {}): FetchArgs {
            const localVarPath = `/api/vfs`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (curPage !== undefined) {
                localVarQueryParameter['cur_page'] = curPage;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiVfsIdDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling apiVfsIdDelete.');
            }
            const localVarPath = `/api/vfs/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiVfsIdGet(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling apiVfsIdGet.');
            }
            const localVarPath = `/api/vfs/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {InFileDto} inFileDto
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiVfsIdPut(inFileDto: InFileDto, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'inFileDto' is not null or undefined
            if (inFileDto === null || inFileDto === undefined) {
                throw new RequiredError('inFileDto','Required parameter inFileDto was null or undefined when calling apiVfsIdPut.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling apiVfsIdPut.');
            }
            const localVarPath = `/api/vfs/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"InFileDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(inFileDto || {}) : (inFileDto || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {InFileDto} inFileDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiVfsPost(inFileDto: InFileDto, options: any = {}): FetchArgs {
            // verify required parameter 'inFileDto' is not null or undefined
            if (inFileDto === null || inFileDto === undefined) {
                throw new RequiredError('inFileDto','Required parameter inFileDto was null or undefined when calling apiVfsPost.');
            }
            const localVarPath = `/api/vfs`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"InFileDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(inFileDto || {}) : (inFileDto || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VfsApi - functional programming interface
 * @export
 */
export const VfsApiFp = function(configuration?: Configuration) {
    return {
        /**
         *
         * @param {string} [q] Text for search (default: empty)
         * @param {number} [perPage] Number of results to return per page. (default: 10)
         * @param {number} [curPage] A page number within the paginated result set. (default: 1)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiVfsGet(q?: string, perPage?: number, curPage?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OutFileDto> {
            const localVarFetchArgs = VfsApiFetchParamCreator(configuration).apiVfsGet(q, perPage, curPage, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiVfsIdDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = VfsApiFetchParamCreator(configuration).apiVfsIdDelete(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiVfsIdGet(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OutFileDto> {
            const localVarFetchArgs = VfsApiFetchParamCreator(configuration).apiVfsIdGet(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @param {InFileDto} inFileDto
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiVfsIdPut(inFileDto: InFileDto, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OutFileDto> {
            const localVarFetchArgs = VfsApiFetchParamCreator(configuration).apiVfsIdPut(inFileDto, id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @param {InFileDto} inFileDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiVfsPost(inFileDto: InFileDto, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OutFileDto> {
            const localVarFetchArgs = VfsApiFetchParamCreator(configuration).apiVfsPost(inFileDto, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * VfsApi - factory interface
 * @export
 */
export const VfsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         *
         * @param {string} [q] Text for search (default: empty)
         * @param {number} [perPage] Number of results to return per page. (default: 10)
         * @param {number} [curPage] A page number within the paginated result set. (default: 1)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiVfsGet(q?: string, perPage?: number, curPage?: number, options?: any) {
            return VfsApiFp(configuration).apiVfsGet(q, perPage, curPage, options)(fetch, basePath);
        },
        /**
         *
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiVfsIdDelete(id: number, options?: any) {
            return VfsApiFp(configuration).apiVfsIdDelete(id, options)(fetch, basePath);
        },
        /**
         *
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiVfsIdGet(id: number, options?: any) {
            return VfsApiFp(configuration).apiVfsIdGet(id, options)(fetch, basePath);
        },
        /**
         *
         * @param {InFileDto} inFileDto
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiVfsIdPut(inFileDto: InFileDto, id: number, options?: any) {
            return VfsApiFp(configuration).apiVfsIdPut(inFileDto, id, options)(fetch, basePath);
        },
        /**
         *
         * @param {InFileDto} inFileDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiVfsPost(inFileDto: InFileDto, options?: any) {
            return VfsApiFp(configuration).apiVfsPost(inFileDto, options)(fetch, basePath);
        },
    };
};

/**
 * VfsApi - object-oriented interface
 * @export
 * @class VfsApi
 * @extends {BaseAPI}
 */
export class VfsApi extends BaseAPI {
    /**
     *
     * @param {} [q] Text for search (default: empty)
     * @param {} [perPage] Number of results to return per page. (default: 10)
     * @param {} [curPage] A page number within the paginated result set. (default: 1)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VfsApi
     */
    public apiVfsGet(q?: string, perPage?: number, curPage?: number, options?: any) {
        return VfsApiFp(this.configuration).apiVfsGet(q, perPage, curPage, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @param {} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VfsApi
     */
    public apiVfsIdDelete(id: number, options?: any) {
        return VfsApiFp(this.configuration).apiVfsIdDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @param {} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VfsApi
     */
    public apiVfsIdGet(id: number, options?: any) {
        return VfsApiFp(this.configuration).apiVfsIdGet(id, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @param {} inFileDto
     * @param {} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VfsApi
     */
    public apiVfsIdPut(inFileDto: InFileDto, id: number, options?: any) {
        return VfsApiFp(this.configuration).apiVfsIdPut(inFileDto, id, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @param {} inFileDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VfsApi
     */
    public apiVfsPost(inFileDto: InFileDto, options?: any) {
        return VfsApiFp(this.configuration).apiVfsPost(inFileDto, options)(this.fetch, this.basePath);
    }

}

